---
title: "SnapKin Workflow in R"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{SnapKin_WorkFlow_R}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(SnapKin)
```

# Load Dataset

For this vignette, we will be using the ESC dataset.

```{r}
load('../Data/Phospho_ESC.RData')
head(dat)
```
The ESC dataset consists of time-course phosphoproteomic data stored in a matrix *dat*.

# Assign Labels

Since the training set for SnapKin requires labelled data, we begin by identifying 
known substrates for the kinase MTOR. 
To do this, we refer to the PhosphositePlus database using the PhosR package.


```{r}
# Identify sites 
ids = rownames(dat)
sites = sapply(strsplit(ids, ";"), function(x)paste(x[1], x[2], "", sep=";"))

# Dataframe index of known substrates for MTOR
substrate.ids = which(sites %in% PhosR::PhosphoSite.mouse$MTOR)
y = rep(0, length(sites))
y[substrate.ids] = 1
```

# SnapKin Training and Test Set

Now that we have binary labels for our dataset, we can construct a dataframe that 
can be used to train a SnapKin model with the help of some helper functions.
To begin, we can construct the training set as a dataframe consisting of the 
phosphoproteomic data and labels denoted by *training_set*.
Additionally, we may also construct a test set which only contains the 
phosphoproteomic data denoted by *test_set*.

**Note.** The ids for a site must be of the form **gene;site;amino acid sequence;**.
An additional step may be needed to convert your data into the appropriate format 
and is not included in this vignette.

```{r}
# Preprocessing datasets 
training_set = data.frame(dat, y)
rownames(training_set) = ids 

test_set = data.frame(dat)
rownames(test_set) = ids
source('../R/preprocessSnapKin.R')
```


## SnapKin Preprocessing: preprocessSnapKin

Now that we have our training set (and test set) formatted appropriately, we may 
use *preprocessSnapKin* in order to construct appropriate dataframes for SnapKin.
Specifically, this function computes motif scores, normalises the dataset, and 
includes a *site* column for labelling purposes based off rownames (or set by 
the user).
We illustrate the various scenarios where *preprocessSnapKin* may be used.

### Training and Test Set

In this scenario, we have a labelled training set and a test set (refer to the 
dataframes constructed [above](#SnapKin-Training-Set)).
*preprocessSnapKin* may be used as follows to create a train and test dataframe 
for SnapKin.

**Note.** The sequence score for the test dataset is based off the labelled training
set.

```{r}
# Compute sequence information and returns a list
preprocessed_data = preprocessSnapKin(training_set=training_set,
                                      test_set=test_set)
# Extract the training and test df
train_df = preprocessed_data$training
test_df = preprocessed_data$test
```


Rather than renaming the rownames of your dataframe before using *preprocessSnapKin*, 
*preprocessSnapKin* may also refer to ids directly.

```{r}
# Compute sequence information and returns a list
preprocessed_data = preprocessSnapKin(training_set=training_set,
                                      training_ids=ids,
                                      test_set=test_set,
                                      test_ids=ids)
# Extract the training and test df
train_df = preprocessed_data$training
test_df = preprocessed_data$test
```


### Training Set 

In some cases, we may just be interested in seeing how our model will predict on 
the training set based off the training set. 
*preprocessSnapKin* can be used to do this as follows 

```{r}
# Compute sequence information and returns a list
preprocessed_data = preprocessSnapKin(training_set=training_set)
# Extract the training and test df
train_df = preprocessed_data$training
test_df = preprocessed_data$test
```

In this case, the test dataframe is the same as the training dataframe except it 
doesn't have labels. 
Similarly, we can refer to ids directly as before 

```{r}
# Compute sequence information and returns a list
preprocessed_data = preprocessSnapKin(training_set=training_set,
                                      training_ids=ids)
# Extract the training and test df
train_df = preprocessed_data$training
test_df = preprocessed_data$test
```

# SnapKin

Now that our data is ready for SnapKin to use, we can run SnapKin in R with the 
help of r-reticulate. 
For the following to work, we assume that you have created the appropriate conda 
environment as mentioned in the Github repository. 
Our example uses the *SnapKin* conda environment, specifically Tensorflow with CPU.

```{r}
# Set the conda environment to SnapKin
reticulate::use_condaenv(condaenv = 'SnapKin', required=TRUE)
# reticulate::use_condaenv(condaenv = 'SnapKin-GPU', required=TRUE)

# Load the SnapKin module
Snapkin = reticulate::import_from_path('SnapKin',path = '../Python/')
```


Since SnapKin takes pandas dataframes as inputs, we convert our training and test 
datasets into pandas dataframes using *r_to_py*.

```{r}
# Convert the train/test dataset to pandas dataframes.
snapkin_train = reticulate::r_to_py(train_df)
snapkin_test = reticulate::r_to_py(test_df)
```

Now that the datasets are in the right format, we can run SnapKin using **snapkin**, 
which is a function implemented in Python. 
We can include various arguments as seen below. 

```{r}
predictions = Snapkin$snapkin(df_train=snapkin_train,
                              df_test=snapkin_test,
                              verbose=1,
                              num_layers=3,
                              num_snapshots=10,
                              num_epochs=150,
                              batch_size=32,
                              learning_rate=0.01)
```

This function outputs a R dataframe of SnapKin's predictions for the test set 
that can be easily used.

```{r}
head(predictions)
```










